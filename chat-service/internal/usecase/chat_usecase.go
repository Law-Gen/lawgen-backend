package usecase

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/google/uuid"

	"github.com/LAWGEN/lawgen-backend/chat-service/internal/config"
	"github.com/LAWGEN/lawgen-backend/chat-service/internal/domain"
	"github.com/LAWGEN/lawgen-backend/chat-service/internal/util"
)

type ChatService struct {
	cfg              *config.Config
	sessionRepo      domain.SessionRepository // Redis for active sessions
	chatRepo         domain.ChatRepository    // Redis for active chat history
	mongoSessionRepo domain.SessionRepository // MongoDB for persistent sessions
	mongoChatRepo    domain.ChatRepository    // MongoDB for persistent chat history
	llmService       domain.LLMService
	ragService       domain.RAGService
}

type QueryRequest struct {
	SessionID string // Can be empty for new sessions
	UserID    string // Empty for guests
	PlanID    string // Provided by middleware
	Message   string
	Language  string
}

type ChatResponseChunk struct {
	Text               string
	Sources            []domain.RAGSource // Only in the final chunk
	IsComplete         bool
	Error              error
	SessionID          string   // New session ID if created
	SuggestedQuestions []string // For no-result scenarios
}

func NewChatService(
	cfg *config.Config,
	sessionRepo domain.SessionRepository, // Redis
	chatRepo domain.ChatRepository, // Redis
	mongoSessionRepo domain.SessionRepository, // MongoDB
	mongoChatRepo domain.ChatRepository, // MongoDB
	llmService domain.LLMService,
	ragService domain.RAGService,
) *ChatService {
	return &ChatService{
		cfg:              cfg,
		sessionRepo:      sessionRepo,
		chatRepo:         chatRepo,
		mongoSessionRepo: mongoSessionRepo,
		mongoChatRepo:    mongoChatRepo,
		llmService:       llmService,
		ragService:       ragService,
	}
}

// ProcessQuery orchestrates the entire chat flow
func (s *ChatService) ProcessQuery(ctx context.Context, req QueryRequest) (<-chan ChatResponseChunk, error) {
	resChan := make(chan ChatResponseChunk)

	go func() {
		defer close(resChan)
		s.processQueryInternal(ctx, req, resChan)
	}()

	return resChan, nil
}

func (s *ChatService) processQueryInternal(ctx context.Context, req QueryRequest, resChan chan<- ChatResponseChunk) {
	// 1. Determine UserParams from PlanID
	userParams := domain.GetUserParamsFromPlanID(req.PlanID)
	isGuest := !userParams.SaveHistory // If history is not saved, it's a guest session

	// 2. Retrieve or create session
	var session *domain.Session
	var err error

	if req.SessionID == "" {
		// New session
		session = &domain.Session{
			ID:           uuid.NewString(), // Temp ID for now, MongoID will be generated by repo
			UserID:       req.UserID,
			Language:     req.Language,
			CreatedAt:    time.Now(),
			LastActiveAt: time.Now(),
			IsGuest:      isGuest,
			Title:        "New Chat", // Default title
		}
		if err := s.sessionRepo.CreateSession(ctx, session); err != nil { // Create in Redis
			resChan <- ChatResponseChunk{Error: fmt.Errorf("failed to create session in Redis: %w", err)}
			return
		}
		// If for an account holder, also create in MongoDB
		if userParams.SaveHistory {
			if err := s.mongoSessionRepo.CreateSession(ctx, session); err != nil {
				log.Printf("Warning: Failed to create session %s in MongoDB: %v", session.ID, err)
				// Don't fail the entire request, but log it
			}
		}
		req.SessionID = session.ID                          // Use the newly created ID
		resChan <- ChatResponseChunk{SessionID: session.ID} // Send session ID to client
	} else {
		session, err = s.sessionRepo.GetSessionByID(ctx, req.SessionID) // Try Redis first
		if err != nil {
			if userParams.SaveHistory { // If account holder, try MongoDB if not in Redis
				session, err = s.mongoSessionRepo.GetSessionByID(ctx, req.SessionID)
				if err != nil {
					resChan <- ChatResponseChunk{Error: fmt.Errorf("session not found: %w", err)}
					return
				}
				// Re-cache in Redis
				if err := s.sessionRepo.CreateSession(ctx, session); err != nil {
					log.Printf("Warning: Failed to re-cache session %s in Redis: %v", session.ID, err)
				}
			} else { // Guest session expired from Redis
				resChan <- ChatResponseChunk{Error: fmt.Errorf("guest session expired or not found: %w", err)}
				return
			}
		}

		// Update session last active time and language (if changed)
		session.LastActiveAt = time.Now()
		if req.Language != "" && session.Language != req.Language {
			session.Language = req.Language
		}
		if err := s.sessionRepo.UpdateSession(ctx, session); err != nil { // Update in Redis
			log.Printf("Warning: Failed to update session %s in Redis: %v", session.ID, err)
		}
		// Also update in MongoDB for account holders, but this will be handled by the sync job or a separate update if needed
	}

	// Store user's message
	userChatEntry := domain.ChatEntry{
		SessionID: session.ID,
		Type:      domain.MessageTypeUser,
		Content:   req.Message,
		CreatedAt: time.Now(),
	}
	if err := s.chatRepo.SaveChatEntry(ctx, &userChatEntry); err != nil { // Save to Redis
		log.Printf("Warning: Failed to save user chat entry to Redis: %v", err)
	}

	// 3. Language Conversion (if needed)
	processedQuery := req.Message
	if req.Language != "en" { // Assuming RAG and LLM primarily work in English
		var err error
		processedQuery, err = s.llmService.Translate(ctx, req.Message, "en")
		if err != nil {
			resChan <- ChatResponseChunk{Error: fmt.Errorf("failed to translate message: %w", err)}
			return
		}
	}

	// 4. Refine Query for RAG
	refinementPrompt := strings.ReplaceAll(s.cfg.LLMPromptRefine, "{{.Query}}", processedQuery)
	refinedQuery, err := s.llmService.Generate(ctx, refinementPrompt, nil) // No history for refinement
	log.Printf("\n### Refinement Service\nPrompt: %s\nResult: %s\nError: %v\n", refinementPrompt, refinedQuery, err)
	if err != nil {
		log.Printf("Warning: Failed to refine query, falling back to original: %v", err)
		refinedQuery = processedQuery // Fallback
	}

	// 5. Retrieve Chat History for Context (Sliding Window)
	chatHistory, err := s.chatRepo.GetChatHistory(ctx, session.ID, userParams.ContextWindow) // Limit is num of PAIRS
	if err != nil {
		log.Printf("Warning: Failed to retrieve chat history from Redis: %v", err)
		chatHistory = []domain.ChatEntry{} // Continue with empty history
	}

	// 6. RAG Retrieval
	ragResult, err := s.ragService.Retrieve(ctx, refinedQuery, userParams.MaxReferences)
	log.Printf("\n### RAG Service\nQuery: %s\nResult: %+v\nError: %v\n", refinedQuery, ragResult, err)
	if err != nil {
		// Log the real error for debugging
		log.Printf("RAG retrieval error: %v", err)
		// Send a generic error to the user
		resChan <- ChatResponseChunk{Error: fmt.Errorf("Sorry, the legal document retrieval service is temporarily unavailable. Please try again later.")}
		return
	}

	// 7. LLM Answer Generation
	var llmAnswerBuilder strings.Builder

	if len(ragResult.Results) == 0 {
		// No RAG results, use LLM to suggest related questions
		suggestionsPrompt := strings.ReplaceAll(s.cfg.LLMPromptNoResult, "{{.Query}}", processedQuery)
		suggestionsStr, err := s.llmService.Generate(ctx, suggestionsPrompt, nil)
		log.Printf("\n### LLM No-Result Suggestions\nPrompt: %s\nResult: %s\nError: %v\n", suggestionsPrompt, suggestionsStr, err)
		if err != nil {
			log.Printf("Error generating no-result suggestions: %v", err)
			suggestionsStr = "Please try rephrasing your question."
		}
		resChan <- ChatResponseChunk{
			Text:               "I couldn't find information related to your question.",
			IsComplete:         true,
			SuggestedQuestions: strings.Split(suggestionsStr, "\n"),
		}
		return
	}

	// Build collected document references for LLM prompt
	var collectedDocsBuilder strings.Builder
	for _, source := range ragResult.Results {
		collectedDocsBuilder.WriteString(fmt.Sprintf("[Source: %s, Article: %s]\n%s\n", source.Source, source.ArticleNumber, source.Content))
	}

	// Prepare history for LLM prompt
	var historyBuilder strings.Builder
	for _, entry := range chatHistory {
		if entry.Type == domain.MessageTypeUser {
			historyBuilder.WriteString(fmt.Sprintf("User: %s\n", entry.Content))
		} else if entry.Type == domain.MessageTypeLLM {
			historyBuilder.WriteString(fmt.Sprintf("Assistant: %s\n", entry.Content))
		}
	}

	// Build the final prompt using the template from config
	finalLLMPrompt := s.cfg.LLMPromptAnswer
	finalLLMPrompt = strings.ReplaceAll(finalLLMPrompt, "{{.RAGResults}}", collectedDocsBuilder.String())
	finalLLMPrompt = strings.ReplaceAll(finalLLMPrompt, "{{.ChatHistory}}", historyBuilder.String())
	finalLLMPrompt = strings.ReplaceAll(finalLLMPrompt, "{{.Query}}", processedQuery)
	finalLLMPrompt = strings.ReplaceAll(finalLLMPrompt, "{{.MaxWords}}", fmt.Sprintf("%d", userParams.MaxAnswerWords))
	finalLLMPrompt = strings.ReplaceAll(finalLLMPrompt, "{{.MaxRefs}}", fmt.Sprintf("%d", userParams.MaxReferences))
	log.Printf("\n### LLM Service\nPrompt: %s\n", finalLLMPrompt)

	// Stream LLM response word-by-word with minimal latency, translating each chunk if needed
	llmStream, err := s.llmService.StreamGenerate(ctx, finalLLMPrompt, chatHistory, userParams.MaxAnswerWords)
	if err != nil {
		resChan <- ChatResponseChunk{Error: fmt.Errorf("failed to stream LLM response: %w", err)}
		return
	}
	for chunk := range llmStream {
		if chunk.Error != nil {
			resChan <- ChatResponseChunk{Error: fmt.Errorf("LLM stream error: %w", chunk.Error)}
			return
		}
		if chunk.Done {
			break
		}
		words := strings.Fields(chunk.Chunk)
		for _, word := range words {
			outText := word + " "
			// If user requested non-English, translate each chunk using HTTP API
			if req.Language != "en" {
				translated, err := util.TranslateText(s.cfg.TranslateApiUrl, outText, req.Language)
				if err == nil && translated != "" {
					outText = translated + " "
				}
			}
			time.Sleep(30 * time.Millisecond)
			resChan <- ChatResponseChunk{Text: outText}
		}
		llmAnswerBuilder.WriteString(chunk.Chunk)
		log.Printf("\n### LLM Stream Chunk\nChunk: %s\n", chunk.Chunk)
	}

	// ...existing code above...

	// 8. Post-processing and strict enforcement
	finalAnswer := s.enforceLimits(llmAnswerBuilder.String(), userParams.MaxAnswerWords)
	finalSources := s.filterSources(ragResult.Results, userParams.MaxReferences)

	// Send final chunk with sources and completion signal
	resChan <- ChatResponseChunk{
		Sources:    finalSources,
		IsComplete: true,
	}

	// 9. Store LLM's Answer
	llmChatEntry := domain.ChatEntry{
		SessionID: session.ID,
		Type:      domain.MessageTypeLLM,
		Content:   finalAnswer,
		Sources:   finalSources,
		CreatedAt: time.Now(),
	}
	// Only save history for guests in Redis (in-memory)
	if session.IsGuest {
		if err := s.chatRepo.SaveChatEntry(ctx, &llmChatEntry); err != nil {
			// If context was canceled, try saving after stream is done
			if err.Error() == "failed to save chat entry to Redis: context canceled (client disconnected or request timed out)" {
				// Try saving again with a new context
				go func() {
					saveCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
					defer cancel()
					if err2 := s.chatRepo.SaveChatEntry(saveCtx, &llmChatEntry); err2 != nil {
						log.Printf("Warning: Final save to Redis after stream also failed: %v", err2)
					} else {
						log.Printf("Info: Final save to Redis after stream succeeded for guest session %s", session.ID)
					}
				}()
			} else {
				log.Printf("Warning: Failed to save LLM chat entry to Redis: %v", err)
			}
		}
	}
}

// enforceLimits ensures the response adheres to word limits
func (s *ChatService) enforceLimits(text string, maxWords int) string {
	words := strings.Fields(text)
	if len(words) > maxWords {
		return strings.Join(words[:maxWords], " ") + "..."
	}
	return text
}

// filterSources ensures the number of references adheres to limits
func (s *ChatService) filterSources(sources []domain.RAGSource, maxRefs int) []domain.RAGSource {
	if len(sources) > maxRefs {
		return sources[:maxRefs]
	}
	return sources
}

// ListSessions retrieves sessions for a user from MongoDB
func (s *ChatService) ListSessions(ctx context.Context, userID string, page, limit int) ([]*domain.Session, int, error) {
	return s.mongoSessionRepo.GetSessionsByUserID(ctx, userID, page, limit)
}

// GetSession retrieves a session for a user from MongoDB (for listing/details, not active use)
func (s *ChatService) GetSession(ctx context.Context, sessionID string) (*domain.Session, error) {
	return s.mongoSessionRepo.GetSessionByID(ctx, sessionID)
}

// ListMessages retrieves messages for a session from MongoDB
func (s *ChatService) ListMessages(ctx context.Context, sessionID string, limit int) ([]domain.ChatEntry, error) {
	return s.mongoChatRepo.GetChatHistory(ctx, sessionID, limit)
}

// SyncChatHistoryFromRedisToDB is a background job function to sync account holder's chat history
func (s *ChatService) SyncChatHistoryFromRedisToDB(ctx context.Context) {
	ticker := time.NewTicker(s.cfg.ChatHistorySyncInterval)
	defer ticker.Stop()

	log.Printf("Starting chat history sync from Redis to MongoDB with interval: %s", s.cfg.ChatHistorySyncInterval)

	for {
		select {
		case <-ctx.Done():
			log.Println("Chat history sync stopped.")
			return
		case <-ticker.C:
			log.Println("Running chat history sync cycle...")
			sessionIDs, err := s.sessionRepo.GetUserSessionIDs(ctx) // Get all active user sessions from Redis Set
			if err != nil {
				log.Printf("Error fetching active user session IDs for sync: %v", err)
				continue
			}

			if len(sessionIDs) == 0 {
				log.Println("No active user sessions to sync.")
				continue
			}

			for _, sessionID := range sessionIDs {
				// 1. Get unsynced chat entries for this session from Redis
				unsyncedEntries, err := s.chatRepo.GetUnsyncedChatEntries(ctx, sessionID)
				if err != nil {
					log.Printf("Error getting unsynced chat entries for session %s from Redis: %v", sessionID, err)
					continue
				}

				if len(unsyncedEntries) == 0 {
					// log.Printf("No unsynced entries for session %s.", sessionID) // Too verbose
					continue
				}

				// 2. Bulk save these unsynced entries to MongoDB
				err = s.mongoChatRepo.BulkSaveChatEntries(ctx, unsyncedEntries)
				if err != nil {
					log.Printf("Error bulk saving unsynced chat entries for session %s to MongoDB: %v", sessionID, err)
					continue
				}
				log.Printf("Synced %d chat entries for session %s to MongoDB.", len(unsyncedEntries), sessionID)

				// 3. Mark these entries as synced in Redis
				var syncedMongoIDs []string
				for _, entry := range unsyncedEntries {
					syncedMongoIDs = append(syncedMongoIDs, entry.MongoID.Hex())
				}
				err = s.chatRepo.MarkChatEntriesAsSynced(ctx, sessionID, syncedMongoIDs)
				if err != nil {
					log.Printf("Error marking chat entries as synced in Redis for session %s: %v", sessionID, err)
					// This is a critical point. If marking fails, these will be re-synced.
					// Consider robust error handling or a separate retry mechanism.
				}
			}
			log.Println("Chat history sync cycle completed.")
		}
	}
}
